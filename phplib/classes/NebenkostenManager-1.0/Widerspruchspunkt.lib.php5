<?php
/**
 * Diese Klasse repräsentiert einen Widerspruchspunkt
 * 
 * @access   	public
 * @author   	Stephan Walleczek <s.walleczek@stollvongati.com>
 *
 * @since    	PHP 5.0
 * @version		1.0
 * @copyright 	Copyright (c) 2009 Stoll von Gáti GmbH www.stollvongati.com
 */
class Widerspruchspunkt extends DBEntry 
{
	/**
	 * Datenbankname und Spalten
	 * @var string
	 */
	const TABLE_NAME = "widerspruchspunkt";
	
	/**
	 * Überschrift
	 * @var string
	 */
	protected $title = "";
	
	/**
	 * Text 'Standpunkt Name Eigentümer/Verwalter/ Anwalt'
	 * @var string
	 */
	protected $textLeft = "";		
	
	/**
	 * Text 'Standpunkt Name Kunde'
	 * @var string
	 */
	protected $text = "";
	
	/**
	 * Sorting rank
	 * @var int
	 */
	protected $rank = 0;
	
	/**
	 * Hidden in WS
	 * @var boolean
	 */
	protected $hidden = false;
	
	/**
	 * Zugehöriger Widerspruch
	 * @var Widerspruch
	 */
	protected $widerspruch = null;
	
	/**
	 * Wurde dieser WS-Punkt vom Widerspruchsgenerator erzeugt?
	 * @var boolean 
	 */
	protected $autoGenerated = false;
	
	/**
	 * Konstruktor
	 * @param DBManager $db
	 */
	public function Widerspruchspunkt(DBManager $db)
	{
		$dbConfig = new DBConfig();
		$dbConfig->tableName = self::TABLE_NAME;
		$dbConfig->rowName = Array("title", "textLeft", "text", "rank", "hidden", "autoGenerated", "widerspruch");
		$dbConfig->rowParam = Array("LONGTEXT", "LONGTEXT", "LONGTEXT", "BIGINT", "INT", "INT", "BIGINT");
		$dbConfig->rowIndex = Array("rank", "widerspruch");
		parent::__construct($db, $dbConfig);
	}
	
	/**
	 * Erzeugt zwei Array: in Einem die Spaltennamen und im Anderen der Spalteninhalt
	 * @param &array  	$rowName	Muss nach dem Aufruf die Spaltennamen enthalten
	 * @param &array  	$rowData	Muss nach dem Aufruf die Spaltendaten enthalten
	 * @return bool/int				Im Erfolgsfall true oder 
	 *								-1 Name leer
	 *								-2 Text leer
	 *								-3 Kein Widerspruch zugeordnet
	 */
	protected function BuildDBArray(&$db, &$rowName, &$rowData)
	{
		// Array mit zu speichernden Daten anlegen
		if (trim($this->title)=="") return -1;
		if (trim($this->text)=="") return -2;
		if ($this->widerspruch==null) return -3;
		$rowName[]= "title";
		$rowData[]= $this->title;
		$rowName[]= "text";
		$rowData[]= $this->text;
		$rowName[]= "textLeft";
		$rowData[]= $this->textLeft;
		$rowName[]= "rank";
		$rowData[]= (int)$this->rank;
		$rowName[]= "hidden";
		$rowData[]= $this->hidden ? 1 : 0;
		$rowName[]= "autoGenerated";
		$rowData[]= $this->autoGenerated ? 1 : 0;
		$rowName[]= "widerspruch";
		$rowData[]= ($this->widerspruch==null ? -1 : $this->widerspruch->GetPKey());
		return true;
	}
	
	/**
	 * Füllt die Variablen dieses Objektes mit den Daten aus der Datenbankl
	 * @param array $data Assoziatives Array mit den Daten aus der Datenbank
	 * @return bool
	 */
	protected function BuildFromDBArray(&$db, $data)
	{
		// Daten aus Array in Attribute kopieren
		$this->title = $data['title'];
		$this->text = $data['text'];
		$this->textLeft = $data['textLeft'];
		$this->rank = (int)$data['rank'];
		$this->hidden = ($data['hidden']==1 ? true : false);
		$this->autoGenerated = ($data['autoGenerated']==1 ? true : false);

		if( is_a($data['widerspruch'], "Widerspruch"))
		{
			$this->widerspruch=$data['widerspruch'];
		}
		elseif( $data['widerspruch']!=-1 )
		{
			$this->widerspruch = new Widerspruch($db);
			if (!$this->widerspruch->Load($data['widerspruch'], $db)) $this->widerspruch=null;
		}
		else
		{
			$this->widerspruch=null;
		}
		return true;
	}
	
	/**
	 * Setzt die Überschrift
	 * @param string $title
	 * @return bool
	 */
	public function SetTitle($title)
	{
		$this->title=$title;
		return true;
	}
	
	/**
	 * Gibt die Überschrift zurück
	 * @return string
	 */
	public function GetTitle()
	{
		return $this->title;
	}

	/**
	 * Setzt den Text 'Standpunkt Name Eigentümer/Verwalter/ Anwalt'
	 * @param string	$text		Text
	 * @return bool				Erfolg
	 */
	public function SetTextLeft($text)
	{
		$this->textLeft = $text;
		return true;
	}
	
	/**
	 * Gibt den Text 'Standpunkt Name Eigentümer/Verwalter/ Anwalt' zurück
	 * @return string
	 */
	public function GetTextLeft()
	{
		return $this->textLeft;
	}
	
	/**
	 * Setzt den Text 'Standpunkt Name Kunde'
	 * @param string $text
	 * @return bool
	 */
	public function SetTextRight($text)
	{
		$this->text = $text;
		return true;
	}
	
	/**
	 * Gibt den Text 'Standpunkt Name Kunde' zurück
	 * @return string			Text
	 */
	public function GetTextRight()
	{
		return $this->text;
	}
	
	/**
	 * Set the sorting rank
	 * @param int $rank
	 * @return bool
	 */
	public function SetRank($rank)
	{
		$this->rank = $rank;
		return true;
	}
	
	/**
	 * Return the sorting rank
	 * @return int
	 */
	public function GetRank()
	{
		return $this->rank;
	}
	
	/**
	 * Set if the WSP is hidden or not
	 * @param boolean $hidden
	 * @return boolean
	 */
	public function SetHidden($hidden)
	{
		if (!is_bool($hidden)) return false;
		$this->hidden = $hidden;
		return true;
	}
	
	/**
	 * return if the WSP is hidden or not
	 * @return boolean
	 */
	public function IsHidden()
	{
		return $this->hidden;
	}
	
	
	/**
	 * Set if the WSP is autogenerated or not
	 * @param boolean $autoGenerated
	 * @return boolean
	 */
	public function SetAutoGenerated($autoGenerated)
	{
		if (!is_bool($autoGenerated)) return false;
		$this->autoGenerated = $autoGenerated;
		return true;
	}
	
	/**
	 * return if the WSP is autogenerated or not
	 * @return boolean
	 */
	public function IsAutoGenerated()
	{
		return $this->autoGenerated;
	}

	/**
	 * @param DBManager $db
	 * @return array
	 */
	public function GetKuerzungsbetraegeMatrix(DBManager $db)
	{
		$returnValues = array();
		foreach(Kuerzungsbetrag::GetEinsparungsTypen() as $einsparungType)
		{
			$returnValues[$einsparungType] = Array();
			foreach(Kuerzungsbetrag::GetTypes() as $type)
			{
				$returnValues[$einsparungType][$type] = Array();
				foreach(Kuerzungsbetrag::GetRatings() as $rating)
				{
					$returnValues[$einsparungType][$type][$rating] = 0.0;
					$returnValues["r"][$einsparungType][$type][$rating] = Kuerzungsbetrag::KUERZUNGSBETRAG_REALISIERT_NO;
				}
			}
		}

		$kuerzungsbetraege = $this->GetKuerzungsbetraege($db);
		foreach($kuerzungsbetraege as $kuerzungsbetraeg)
		{
			$returnValues[$kuerzungsbetraeg->GetEinsparungsTyp()][$kuerzungsbetraeg->GetType()][$kuerzungsbetraeg->GetRating()] += $kuerzungsbetraeg->GetKuerzungsbetrag();
			$returnValues["r"][$kuerzungsbetraeg->GetEinsparungsTyp()][$kuerzungsbetraeg->GetType()][$kuerzungsbetraeg->GetRating()] = $kuerzungsbetraeg->GetRealisiert();
		}
		return $returnValues;
	}

	/**
	 * @param DBManager $db
	 * @param array $kuerzungsbetraege
	 */
	public function SetKuerzungsbetraegeMatrix(DBManager $db, $kuerzungsbetraege, $realisiert=false)
	{
		$returnValues = array();
		$currentKuerzungsbetraege = array();
		$temp = $this->GetKuerzungsbetraege($db);
		$kuerzungsbetraegeToDelete = Array();
		foreach($temp as $obj)
		{
			if (!isset($currentKuerzungsbetraege[$obj->GetEinsparungsTyp()][$obj->GetType()][$obj->GetRating()]))
			{
				$currentKuerzungsbetraege[$obj->GetEinsparungsTyp()][$obj->GetType()][$obj->GetRating()] = $obj;
			}
			else
			{
				// Kürzungsbetrag für dies Kombination EinsparungsTyp, Typ und Ampelfarbe bereits vorhanden -> zum löschen markieren
				$kuerzungsbetraegeToDelete[] = $obj;
			}
		}

		foreach(Kuerzungsbetrag::GetEinsparungsTypen() as $einsparungType)
		{
			foreach(Kuerzungsbetrag::GetTypes() as $type)
			{
				foreach(Kuerzungsbetrag::GetRatings() as $rating)
				{
					if (isset($kuerzungsbetraege[$einsparungType][$type][$rating]))
					{
						if (is_numeric($kuerzungsbetraege[$einsparungType][$type][$rating]))
						{
							$currentKuerzungsbetrag = null;
							if(isset($currentKuerzungsbetraege[$einsparungType][$type][$rating]))
							{
								$currentKuerzungsbetrag = $currentKuerzungsbetraege[$einsparungType][$type][$rating];
							}
							else
							{
								$currentKuerzungsbetrag = new Kuerzungsbetrag($db);
								$currentKuerzungsbetrag->SetEinsparungsTyp($einsparungType);
								$currentKuerzungsbetrag->SetType($type);
								$currentKuerzungsbetrag->SetRating($rating);
								$this->AddKuerzungsbetrag($db, $currentKuerzungsbetrag);
								$currentKuerzungsbetraege[$einsparungType][$type][$rating] = $currentKuerzungsbetrag;
							}
							$currentKuerzungsbetrag->SetKuerzungsbetrag($kuerzungsbetraege[$einsparungType][$type][$rating]);

							if ($realisiert)
							{
								if (is_numeric($kuerzungsbetraege["r"][$einsparungType][$type][$rating]))
								{
									$currentKuerzungsbetrag->SetRealisiert($kuerzungsbetraege["r"][$einsparungType][$type][$rating]);
								}
							}
						}
						else
						{
							$returnValues[$einsparungType][$type][$rating] = "Bitte geben Sie eine gültige Zahl ein";
						}
					}
				}
			}
		}

		foreach(Kuerzungsbetrag::GetEinsparungsTypen() as $einsparungType)
		{
			foreach(Kuerzungsbetrag::GetTypes() as $type)
			{
				foreach(Kuerzungsbetrag::GetRatings() as $rating)
				{
					if(isset($currentKuerzungsbetraege[$einsparungType][$type][$rating]))
					{
						if ($currentKuerzungsbetraege[$einsparungType][$type][$rating]->Store($db)!==true)
						{
							$returnValues[$einsparungType][$type][$rating] = "Konnte nicht gespeichert werden";
						}
					}
				}
			}
		}

		if (count($returnValues)==0)
		{
			// Überflüssige Kürzungbeträge löschen
			foreach($kuerzungsbetraegeToDelete as $obj)
			{
				$obj->DeleteMe($db);
			}
			return true;
		}
		return $returnValues;
	}

	/**
	* Gibt die Anzahl der Kürzungsbeträge zurück
	* @param DBManager $db
	* @return int
	*/
	public function GetKuerzungsbetragCount(DBManager $db)
	{
		if ($this->pkey==-1) return 0;
		$data = $db->SelectAssoc("SELECT count(pkey) as count FROM ".Kuerzungsbetrag::TABLE_NAME." WHERE widerspruchspunkt=".$this->pkey);
		return (int)$data[0]["count"];
	}
	
	/**
	* Gibt alle Kürzungsbeträge zurück
	* @param DBManager $db
	* @return Kuerzungsbetrag[]
	*/
	public function GetKuerzungsbetraege(DBManager $db)
	{
		if ($this->pkey==-1) return Array();
		$data = $db->SelectAssoc("SELECT * FROM ".Kuerzungsbetrag::TABLE_NAME." WHERE widerspruchspunkt=".$this->pkey." ORDER BY pkey");
		$objects = Array();
		for ($a=0; $a<count($data); $a++)
		{
			$object = new Kuerzungsbetrag($db);
			$data[$a]['widerspruchspunkt'] = $this;
			if ($object->LoadFromArray($data[$a], $db)===true) $objects[] = $object;
		}
		return $objects;
	}
		
	/**
	* Ordnet dem Kürzungsbetrag diesen Widerspruchspunkt zu
	* @param DBManager $db
	* @param Kuerzungsbetrag $kuerzungsbetrag
	* @return bool
	*/
	public function AddKuerzungsbetrag(DBManager $db, Kuerzungsbetrag $kuerzungsbetrag)
	{
		if ($this->pkey==-1) return false;
		// Dem Widerspruchspunkt diesen Widerspruch zuweisen...
		return $kuerzungsbetrag->SetWiderspruchspunkt($this);
	}
	
	/**
	 * Gibt den Kürzungbetrag zurück
	 * @param DBManager $db
	 * @param int $einstufung 0 = all
	 * @param int $type 0 = all
	 * @return float
	 */
	public function GetKuerzungbetrag(DBManager $db, $einstufung, $type=0, $realisiert=-1)
	{
		if ($this->GetPKey()==-1) return 0.0;
		$additionalWhereClause = '';
		if ((int)$einstufung>0) $additionalWhereClause.=' AND rating='.(int)$einstufung;
		if ((int)$type>0) $additionalWhereClause.=' AND type='.(int)$type;
		if ((int)$realisiert>-1) $additionalWhereClause.=' AND realisiert='.(int)$realisiert;
		$data = $db->SelectAssoc('SELECT SUM(kuerzungsbetrag) AS summe FROM '.Kuerzungsbetrag::TABLE_NAME.' WHERE widerspruchspunkt='.$this->GetPKey().$additionalWhereClause);
		return (float)$data[0]['summe'];
	}
		
	/**
	 * Gibt die Summe des Widerspruchspunktes zurück (grün + gelb + grau)
	 * @param DBManager $db
	 * @return float
	 */
	public function GetWiderspruchspunktSumme(DBManager $db, $type=0)
	{
		if ($this->GetPKey()==-1) return 0.0;
		$additionalWhereClause = '';
		if ((int)$type>0) $additionalWhereClause.=' AND type='.(int)$type;
		$data = $db->SelectAssoc('SELECT SUM(kuerzungsbetrag) AS summe FROM '.Kuerzungsbetrag::TABLE_NAME.' WHERE widerspruchspunkt='.$this->GetPKey().' AND (rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GRUEN.' OR rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GELB.' OR rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GRAU.') '.$additionalWhereClause);
		return (float)$data[0]['summe'];
	}
	
	/**
	 * Gibt die realisierte Einsparung zurück (grün + gelb)
	 * @param DBManager $db
	 * @return float
	 */
	public function GetRealisierteEinsparung(DBManager $db, $type=0)
	{
		if ($this->GetPKey()==-1) return 0.0;
		$additionalWhereClause = '';
		if ((int)$type>0) $additionalWhereClause.=' AND type='.(int)$type;
		$data = $db->SelectAssoc('SELECT SUM(kuerzungsbetrag) AS summe FROM '.Kuerzungsbetrag::TABLE_NAME.' WHERE widerspruchspunkt='.$this->GetPKey().' AND (rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GRUEN.' OR rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GELB.') '.$additionalWhereClause);
		return (float)$data[0]['summe'];
	}
	
	/**
	 * Gibt die nicht realisierte Einsparung zurück (grau)
	 * @param DBManager $db
	 * @return float
	 */
	public function GetNichtRealisierteEinsparung(DBManager $db)
	{
		if ($this->GetPKey()==-1) return 0.0;
		$data = $db->SelectAssoc('SELECT SUM(kuerzungsbetrag) AS summe FROM '.Kuerzungsbetrag::TABLE_NAME.' WHERE widerspruchspunkt='.$this->GetPKey().' AND rating='.Kuerzungsbetrag::KUERZUNGSBETRAG_EINSTUFUNG_GRAU);
		return (float)$data[0]['summe'];
	}
	
	/**
	 * Returns if all Kuerzungsbetraege are from a specific type
	 * @param DBManager $db
	 * @return boolean
	 */
	public function AllKuerzungsbetraegeOfType(DBManager $db, $type=0)
	{
		if ($this->GetPKey()==-1) return false;
		// count all other types...
		$data = $db->SelectAssoc('SELECT COUNT(pkey) AS num FROM '.Kuerzungsbetrag::TABLE_NAME.' WHERE widerspruchspunkt='.$this->GetPKey().' AND type!='.(int)$type);
		// if there are other types -> not all of them are from the passed type
		return ($data[0]['num']==0 ? true : false);
	}
	
	/**
	 * Gibt den zugehörigen Widerspruch zurück
	 * @return Widerspruch
	 */
	public function GetWiderspruch()
	{
		return $this->widerspruch;
	}
	
	/**
	 * Setzt den zugehörigen Widerspruch
	 * @param Widerspruch $widerspruch
	 * @return bool
	 */
	public function SetWiderspruch(Widerspruch $widerspruch)
	{
		if ($widerspruch->GetPKey()==-1) return false;
		$this->widerspruch = $widerspruch;
		return true;
	}
	
	/**
	 * Legt eine Kopie an. Dieses Objekt ist nach der Operation mit dem übergebenen Widerspruch verknüpft!
	 * @param DBManager $db
	 * @param Widerspruch $widerspruch
	 * @return bool
	 */
	public function Copy(DBManager $db, Widerspruch $widerspruch)
	{
		if ($widerspruch->GetPKey()==-1) return false;
		$kuerzungsbetraege = $this->GetKuerzungsbetraege($db);
		$this->pkey = -1;
		$this->SetWiderspruch($widerspruch);
		$this->Store($db);
		for($a=0; $a<count($kuerzungsbetraege); $a++)
		{
			$kuerzungsbetraege[$a]->Copy($db, $this);
		}
		return true;
	}
	
	/**
	 * Return the related contract
	 * @return Contract
	 */
	public function GetContract()
	{
		$widerspruch = $this->GetWiderspruch();
		if ($widerspruch==null) return $widerspruch;
		return $widerspruch->GetContract();
	}
	
	/**
	 * Return the current currency
	 * @return null 
	 */
	public function GetCurrency()
	{
		$contract = $this->GetContract();
		if ($contract==null) return "";
		return $contract->GetCurrency();
	}
	
}
?>